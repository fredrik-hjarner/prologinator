---
description: Some rules for Prolog files
globs: "*.pl"
alwaysApply: true
---

# Commands

- `just lint-len` to lint the length of the lines
- `just lint-all` to lint all the files
- `just test-all` to test all the files
- `just test-all-verbose` to test all the files with verbose
   output
- `just lint` to lint a single file
- `just test` to test a single file
- `just test-verbose` to test a single file with verbose
   output

# Discouraged Tokens in Prolog Files

Instead of the discouraged tokens, use CLP(Z) constraints:

- Instead of `is`: Use CLP(Z) constraints like `#=` for
  equality
- Instead of `<`: Use `#<` from CLP(Z)
- Instead of `>`: Use `#>` from CLP(Z)
- Instead of `=<`: Use `#=<` from CLP(Z)
- Instead of `>=`: Use `#>=` from CLP(Z)
- Instead of `get_assoc`: Use `gen_assoc`.

# Max 60 characters per line

Yes.

# This project is a one-file monolith

Since Prolog's modules system is so bad I decided to
that it's better to bypass it as much as possible. I do this
by introducing a build step that concatenates all the files
together with gpp into a single file. scryer-prolog is fed
that one file, this all my code is in the same namespace.

# Please use accessors and constructors

Please use the accessors and constructors provided in the
types/accessors.pl and types/constructors.pl files. That
makes the code more robust when if I add or remove fields
from entities. Feel free to refactor code you see to use
accessors and constructors. Also if certain accessors or
constructors are not available, feel free to add them.

# Comment Hierarchy

H1, H2, H3, H4 delimit sections. For non-sections just use 
normal comments. Just like in html if a file has a H2 if
MUST have an H1. If it has a H3 it MUST have an H2 and H1.

## H1 - Major Sections

```prolog
% ==========================================================
% 
%   Context Accessors
% 
% ==========================================================
```

## H2 - Subsections

```prolog
% ==========================================================
% Context Getters
% ==========================================================
```

## H3 - Groups

```prolog
% ----------------------------------------------------------
% Single Field Getters
% ----------------------------------------------------------
```

## H4 - Subgroups

```prolog
% Context Getters ------------------------------------------
```

# DCG Use

We thread context with --> when possible and when it would
be elegant/clean to do so.
Predicates that only read from context are *not* allowed to
simply take in *one* ctx, it still must take in *two* ctxs
so that it'll be easy to use with DCG -->.
Context args *always* comes last.

## Regarding action implementation

This the the convention. Note that we *never* do the
implementation in the body of execute_action_impl but we
have the implementation is a separate predicate whose name
is `execute_${actionName}`.

```
execute_action_impl(
    action(noop),
    actions_old([_|Rest]),
    obj_id(_ID),
    result(completed, actions_new(Rest))
) --> execute_noop.

execute_noop --> [].
```

## Different predicates are disallowed to have the same name

Otherwise they will collide and create a mess and confusion.